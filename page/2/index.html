<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>my blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="my blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="my blog">
<meta property="og:locale">
<meta property="article:author" content="chdo002">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="my blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">my blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-CoreText" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/26/CoreText/" class="article-date">
  <time class="dt-published" datetime="2018-04-26T03:14:30.000Z" itemprop="datePublished">2018-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/26/CoreText/">CoreText</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在CDChatList为了达到页面流畅的效果，用到了coretext，关键点记录如下</p>
<p>聊天页面卡顿点主要有，计算聊天气泡高度、富文本渲染时的性能消耗太大，这两个可以异步操作，并缓存</p>
<p>气泡高度的计算一般都是用NSString的boundingRectWithSize: options: attributes: context:方法计算，算出来的结果可以放在消息Model中缓存并可以本地化，这样就只需计算一次。</p>
<p>富文本渲染有两种方法，UILabel中的attributedText可以复值富文本，但是boundingRectWithSize就不太好用了，而且要考虑到带表情的富文本，所以就得用另一个方法</p>
<p>⬇️</p>
<h1 id="CoreText"><a href="#CoreText" class="headerlink" title="CoreText"></a>CoreText</h1><div style="display:inline">首先需要注意的是，<h3 style="display:inline" >Coretext只有C的接口</h3>，所以得手动管理一些c的内存，同时还得了解字体字形相关信息。</div>

<p>UILabel对coretext进行了封装，我们这里直接调用coretext，可以获得不错的性能表现。</p>
<p>coretext可以实现文本尺寸的计算，文本在子线程绘制，绘制完成后再赋值给view，这样耗时操作都可以不在主线程操作，不影响页面流畅。</p>
<p>上代码</p>
<p>首先创建需要显示的富文本，这里可能包含表情，<br>形如: @”呵呵哒，然后来个表情[微笑][骷髅]”,<br>这里的[微笑][骷髅]就是需要被替换成表情图片，先用正则换成空字符占位，等后续图片绘制，绘制部分具体代码可见CDChatList的CDLabel实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableAttributedString *attString = [[NSMutableAttributedString alloc] initWithString:data.msgString attributes:dic];</span><br><span class="line"></span><br><span class="line">// 先创建framesetter</span><br><span class="line">CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attString);</span><br></pre></td></tr></table></figure>

<p>这步计算文本内容范围，猜测boundingRectWithSize也是用的这个方法，入参很像<br>这里的size就是需要缓存的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CGSize caSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,attString.length), nil, size, nil);</span><br><span class="line"></span><br><span class="line">// 这两步获得需要绘制文本的CGPath和CTFrame</span><br><span class="line">CGPathRef path = CGPathCreateWithRect(CGRectMake(0, 0, caSize.width, caSize.height), NULL);</span><br><span class="line">CTFrameRef frame = CTFramesetterCreateFrame(framesetter,CFRangeMake(0, [attString length]), path, NULL);</span><br><span class="line"></span><br><span class="line">// 注意需要释放内存</span><br><span class="line">CFRelease(framesetter);</span><br><span class="line">CFRelease(path);</span><br></pre></td></tr></table></figure>


<p>渲染展示内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(caSize, NO, 0);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSetTextMatrix(context, CGAffineTransformIdentity);</span><br><span class="line">CGContextTranslateCTM(context, 0, caSize.height);</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0); // coretext坐标系翻转</span><br><span class="line">CTFrameDraw(frame, context);</span><br><span class="line">//.....将上面正则出来的表情图片也绘制在这个context上</span><br></pre></td></tr></table></figure>

<p>最终我们得到这个需要展示的图片内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>

<p>在展示上面的图片时，将他赋给layer的contents<br>这一步必须在主线程执行，可以使用NSCache对此缓存，以达到流畅的效果，且不用担心内存问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.layer.contents = (__bridge id)data.contents.CGImage;</span><br></pre></td></tr></table></figure>

<p>最终效果在GitHub见<a target="_blank" rel="noopener" href="https://github.com/chdo002/cdchatlist">CDChatList</a></p>
<p>参考文章</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liujinlongxa/article/details/44864463">iOS中的富文本技术（2）-CoreText框架</a></p>
<p><a target="_blank" rel="noopener" href="http://www.360doc.com/content/14/0214/15/11991_352473651.shtml">猿题库iOS客户端的技术细节(三):基于CoreText的排版引擎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chaoyuan899/article/details/46662679">基于 CoreText 的排版引擎：基础</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/26/CoreText/" data-id="clvq0zjbu00027qqt0k0l28fe" data-title="CoreText" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-RunLoop应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/25/RunLoop%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2018-04-25T09:25:02.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/25/RunLoop%E5%BA%94%E7%94%A8/">RunLoop应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>网上关于runloop的解析已经更丰富了，这里只记录runloop的实践部分</p>
</blockquote>
<p>RunLoop</p>
<h1 id="干嘛的"><a href="#干嘛的" class="headerlink" title="干嘛的"></a>干嘛的</h1><p>为了实现线程不退出，可以随时接受消息执行任务，<br>node.js 的事件处理，windows程序的消息循环，iOS、OSX的RunLoop都是这种机制</p>
<p>线程和runloop一一对应，关系保存在全局字典中</p>
<p>主线程自带runloop，无需创建，新建的线程需要手动对应runloop，不让执行完成就结束了</p>
<h1 id="常驻线程"><a href="#常驻线程" class="headerlink" title="常驻线程"></a>常驻线程</h1><p>常驻线程的意义，我理解是用来处理需要在子线程长期处理的事情，比如说记日志，埋点，IO数据处理等等之类。</p>
<p>这样想的话其实和NSOperationqueue或者GCD实现一个串行队列应该没有什么区别。</p>
<p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static NSThread *workThread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(void)initThread&#123;</span><br><span class="line"></span><br><span class="line">	workThread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line"></span><br><span class="line">	[workThread start];</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">// 让子线程runloop跑起来，防止线程结束</span><br><span class="line">-(void)run&#123;</span><br><span class="line"></span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    </span><br><span class="line">    while (!_stopRunning) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这段代码直接复制自weex</span><br><span class="line">// 在子线程执行代码</span><br><span class="line">+ (void)_performBlockOnBridgeThread:(void (^)(void))block</span><br><span class="line">&#123;</span><br><span class="line">    if ([NSThread currentThread] == workThread) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self performSelector:@selector(_performBlockOnBridgeThread:)</span><br><span class="line">                     onThread:[self jsThread]</span><br><span class="line">                   withObject:[block copy]</span><br><span class="line">                waitUntilDone:NO];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="runloop-observer"><a href="#runloop-observer" class="headerlink" title="runloop  observer"></a>runloop  observer</h1><p>可以通过CFRunLoopAddObserver，给runloop添加观察者，具体实践如下</p>
<p>这是CDChatList中的一段代码，主要是为了实现，label在scrollview滚动时，去除选中文字的样式，如果不用runloop也是可以用通知或者其他的代理形式实现，但是会有一定的耦合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">currentMode = CFRunLoopCopyCurrentMode(CFRunLoopGetMain());</span><br><span class="line"></span><br><span class="line"> __weak typeof(self) weakS = self;</span><br><span class="line">// 这里监听了所有的runloop事件，然后在回调中过滤出滚动事件，因为滚动事件会一直回调，所以这里需要特别处理，只观察进入滚动的时机</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">    if (weakS) &#123;</span><br><span class="line">        __strong typeof(weakS) strongS = weakS;</span><br><span class="line">        CFComparisonResult rest = CFStringCompare(strongS-&gt;currentMode, CFRunLoopCopyCurrentMode(CFRunLoopGetMain()), kCFCompareBackwards);</span><br><span class="line">        if (rest != kCFCompareEqualTo) &#123;</span><br><span class="line">            strongS-&gt;currentMode = CFRunLoopCopyCurrentMode(CFRunLoopGetMain());</span><br><span class="line">            if ((NSString *)CFBridgingRelease(strongS-&gt;currentMode) == UITrackingRunLoopMode) &#123;</span><br><span class="line">                [strongS scrollDidScroll];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>




<p>下面是YYTransaction中相关的代码，具有类似的实现，这里监听的目的应该是在runloop将要进入休眠时，把不需要立即执行的任务执行，以达到async的效果。</p>
<p>在AsyncDisplayKit中也有类似的用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static NSMutableSet *transactionSet = nil;</span><br><span class="line"></span><br><span class="line">static void YYRunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    if (transactionSet.count == 0) return;</span><br><span class="line">    NSSet *currentSet = transactionSet;</span><br><span class="line">    transactionSet = [NSMutableSet new];</span><br><span class="line">    [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, BOOL *stop) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">        [transaction.target performSelector:transaction.selector];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void YYTransactionSetup() &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        transactionSet = [NSMutableSet new];</span><br><span class="line">        CFRunLoopRef runloop = CFRunLoopGetMain();</span><br><span class="line">        CFRunLoopObserverRef observer;</span><br><span class="line">        </span><br><span class="line">        observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(),</span><br><span class="line">                                           kCFRunLoopBeforeWaiting | kCFRunLoopExit,</span><br><span class="line">                                           true,      // repeat</span><br><span class="line">                                           0xFFFFFF,  // after CATransaction(2000000)</span><br><span class="line">                                           YYRunLoopObserverCallBack, NULL);</span><br><span class="line">        CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        CFRelease(observer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/25/RunLoop%E5%BA%94%E7%94%A8/" data-id="clvq0zjby00077qqt17ldebsz" data-title="RunLoop应用" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-GCD之NSoperation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/20/GCD%E4%B9%8BNSoperation/" class="article-date">
  <time class="dt-published" datetime="2018-04-20T03:00:03.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/20/GCD%E4%B9%8BNSoperation/">GCD之NSoperation</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>NSOperation是基于GCD的面相对象封装，这里把重点计一下。</p>
</blockquote>
<h1 id="NSoperation的dependency"><a href="#NSoperation的dependency" class="headerlink" title="NSoperation的dependency"></a>NSoperation的dependency</h1><p>任务依赖是NSoperation的重要功能，可以让GCD的任务同步更直观的实现出来，不过有些地方也需要注意。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;1-1: %@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;2-1&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[op1 addDependency:op2];</span><br><span class="line"></span><br><span class="line">[op2 start];</span><br><span class="line">[op1 start];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于op1依赖于op2的完成，如果<code>[op1 start]</code>写在<code>[op2 start]</code>前面的话，</p>
<p>会抛出异常<code>-[__NSOperationInternal _start:]: receiver is not yet ready to execute</code>,</p>
<p>你可以这么写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *qq = [[NSOperationQueue alloc] init];</span><br><span class="line"> </span><br><span class="line"> NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">     NSLog(@&quot;1-1: %@&quot;,[NSThread currentThread]);</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">     NSLog(@&quot;2-1&quot;);</span><br><span class="line">     </span><br><span class="line">     NSLog(@&quot;2-3&quot;);</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> [op1 addDependency:op2];</span><br><span class="line"> </span><br><span class="line"> [qq addOperation:op1];</span><br><span class="line"> [qq addOperation:op2];</span><br></pre></td></tr></table></figure>

<p>就不需要关心触发顺序的问题了，因为NSOperationQueue会帮你管理</p>
<h1 id="NSoperation的queuePriority"><a href="#NSoperation的queuePriority" class="headerlink" title="NSoperation的queuePriority"></a>NSoperation的queuePriority</h1><p>queuePriority是次于dependency的属性，在dependency没有指明的情况下，NSOperationQueue会依据NSOperation的queuePriority来决定执行先后。</p>
<h1 id="异步任务的同步问题"><a href="#异步任务的同步问题" class="headerlink" title="异步任务的同步问题"></a>异步任务的同步问题</h1><p>看以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">   </span><br><span class="line">   NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">       NSLog(@&quot;start-1&quot;);</span><br><span class="line">       dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          NSLog(@&quot;end-1&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">       NSLog(@&quot;start-2&quot;);</span><br><span class="line">       dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">           NSLog(@&quot;end-2&quot;);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   [op1 addDependency:op2];</span><br><span class="line">   </span><br><span class="line">   [queue addOperation:op1];</span><br><span class="line">   [queue addOperation:op2];</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-04-23 09:27:57.391220+0800 testP[20559:439375] start-2</span><br><span class="line">2018-04-23 09:27:57.391494+0800 testP[20559:439382] start-1</span><br><span class="line">2018-04-23 09:27:59.583992+0800 testP[20559:439102] end-2</span><br><span class="line">2018-04-23 09:27:59.584309+0800 testP[20559:439102] end-1</span><br></pre></td></tr></table></figure>


<p>可以发现，operationqueue对异步任务是不能同步的，想要实现对异步任务的同步，就得重写NSOperation子类，也就是控制他的isFinished属性。</p>
<p>NSOperation是通过KVO isFinished&#x2F;isExecuting等属性来判断任务的生命周期，重写这几个关键属性就可以了，上代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface SubOperation:NSBlockOperation</span><br><span class="line">&#123;</span><br><span class="line">    // 这是我们用来代替isFinishe的属性</span><br><span class="line">    BOOL sub_isFinish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(void)stopOperation;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubOperation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 重写isFinished，替换掉他</span><br><span class="line">-(BOOL)isFinished&#123;</span><br><span class="line">    return sub_isFinish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 这里需要手动调用此方法，来告诉operation，需要调用isFinished来结束operation</span><br><span class="line"> * 为什么没有直接调，setvalueforkey的方法呢，试试看就知道了</span><br><span class="line"> */ </span><br><span class="line"></span><br><span class="line">-(void)stopOperation&#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">    sub_isFinish = YES;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>现在重新测试下，需要加上我们手动的方法，可以发现可以实现异步任务同步了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">    __block SubOperation *op1;</span><br><span class="line">    op1 = [SubOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;start-1&quot;);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSLog(@&quot;end-1&quot;);</span><br><span class="line">            [op1 stopOperation];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    __block SubOperation *op2;</span><br><span class="line">    op2 = [SubOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;start-2&quot;);</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            NSLog(@&quot;end-2&quot;);</span><br><span class="line">            [op2 stopOperation];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op1 addDependency:op2];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2018-04-23 09:30:41.700824+0800 testP[20651:442268] start-2</span><br><span class="line">2018-04-23 09:30:43.895327+0800 testP[20651:442214] end-2</span><br><span class="line">2018-04-23 09:30:43.895927+0800 testP[20651:442271] start-1</span><br><span class="line">2018-04-23 09:30:46.089130+0800 testP[20651:442214] end-1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4b1d77054b35%22">iOS多线程：『NSOperation、NSOperationQueue』详尽总结</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/20/GCD%E4%B9%8BNSoperation/" data-id="clvq0zjbu00037qqtfwkheg19" data-title="GCD之NSoperation" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-其他杂项" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/16/%E5%85%B6%E4%BB%96%E6%9D%82%E9%A1%B9/" class="article-date">
  <time class="dt-published" datetime="2018-04-16T03:41:16.000Z" itemprop="datePublished">2018-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/16/%E5%85%B6%E4%BB%96%E6%9D%82%E9%A1%B9/">其他杂项</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="给iOS模拟器录屏"><a href="#给iOS模拟器录屏" class="headerlink" title="给iOS模拟器录屏"></a>给iOS模拟器录屏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl io booted recordVideo filename.mov</span><br></pre></td></tr></table></figure>



<h2 id="iTunes-提交没有版本"><a href="#iTunes-提交没有版本" class="headerlink" title="iTunes 提交没有版本"></a>iTunes 提交没有版本</h2><h3 id="2018-04-16-11-41-16"><a href="#2018-04-16-11-41-16" class="headerlink" title="2018-04-16 11:41:16"></a>2018-04-16 11:41:16</h3><p>提交到iTunes connect 上看不到版本，可能是某些隐私权限你用到了，但是没有在info.plist中说明，比如说蓝牙，这也不会导致测试环境下的崩溃，但生产下就不行了</p>
<h2 id="GCD的线程数目"><a href="#GCD的线程数目" class="headerlink" title="GCD的线程数目"></a>GCD的线程数目</h2><p>GCD会维护一个线程池，而线程池中的线程数目是有上限的，具体数字在64位系统上是64，32位系统还没有机会测试</p>
<p>具体的影响，如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    dispatch_queue_t quq = dispatch_queue_create(&quot;affa&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    int taskAmount = 64;</span><br><span class="line">    for (int i = 0; i&lt;taskAmount; i++) &#123;</span><br><span class="line">        dispatch_async(quq, ^&#123;</span><br><span class="line">            sleep(2);</span><br><span class="line">            NSLog(@&quot;--%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直觉上，因为用了dispatch_async，所以应该不会卡主线程，实际上，因为dispatch_async用光了64条线程，其中包含了主线程，所以界面就会卡2秒。</p>
<p>更进一步，如果这里的taskAmount是64的n(n&gt;&#x3D;1，n为正整数)倍，那么卡顿时间也会变成2*n秒时间。</p>
<p>这种情况下就需要手动的控制并发数量，其实用NSOperationqueue就可以直接的控制，GCD的话没有直接设置的方法，只能用信号量达到类似效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t workConcurrentQueue = dispatch_queue_create(&quot;workQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;controllQueue&quot;,DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(4);    // create semaphore: value = 3</span><br><span class="line"></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;begin: %@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        __block int index = i;</span><br><span class="line">        </span><br><span class="line">			dispatch_group_async(group, serialQueue, ^&#123;</span><br><span class="line">            // If value &lt; 0, then wait here. Else value &gt; 0, then pass, and value -1</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            dispatch_group_async(group, workConcurrentQueue, ^&#123;</span><br><span class="line">                sleep(1);</span><br><span class="line">                NSLog(@&quot;执行第%d次操作，线程：%@&quot;,index, [NSThread currentThread]);</span><br><span class="line">                dispatch_semaphore_signal(semaphore);                // Perform value +1</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, workConcurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;okk&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>



<h2 id="泛型实例化"><a href="#泛型实例化" class="headerlink" title="泛型实例化"></a>泛型实例化</h2><p>OC中的泛型是所谓的轻量化泛型，暂时还不知道怎么实现泛型实例化，swift中的实现记录在下面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func testFunc&lt;T: NSObject&gt;(cls:T) -&gt; T &#123;</span><br><span class="line">    let obj = T()</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testFunc(cls: NSString())</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="extern-static-const-关键字"><a href="#extern-static-const-关键字" class="headerlink" title="extern static const 关键字"></a>extern static const 关键字</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2fd58ed2cf55">https://www.jianshu.com/p/2fd58ed2cf55</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3fa703e80720">https://www.jianshu.com/p/3fa703e80720</a></p>
<h2 id="LayoutIfNeeded小理解"><a href="#LayoutIfNeeded小理解" class="headerlink" title="LayoutIfNeeded小理解"></a>LayoutIfNeeded小理解</h2><p>这个方法和另一个方法配对的，setNeedLayout和layoutIfNeed，还有一个关联的方法是layoutSubviews，在我们没有任何干预的情况下，一个view的fram或bounds发生变化时，系统会设置一个flag给这个view，当下一个渲染时机到来时系统会重新按新的布局来渲染视图。setNeedLayout就是我们主动为这个视图设置一个flag，告诉系统这个视图再下一个时机到来时要重新渲染，而layoutIfNeed则是告诉系统，如果设置了flag那么不用等待时机到来了，直接渲染吧。而layoutSubviews这个方法是系统调用的，我们不需要主动调用，我们只需要调用layoutIfNeed就可以了，让系统判断是否在当前时机下立即渲染。</p>
<h2 id="cocoapods"><a href="#cocoapods" class="headerlink" title="cocoapods"></a>cocoapods</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/89605e02bf18">https://www.jianshu.com/p/89605e02bf18</a></p>
<h2 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>在这个<a target="_blank" rel="noopener" href="https://github.com/awesome-tips/iOS-Tips/blob/master/2018/01.md">文章</a>看到.</p>
<p>详解在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hlwfirst/p/5492493.html">这里</a></p>
<h2 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I&#x2F;O"></a>Dispatch I&#x2F;O</h2><p><a target="_blank" rel="noopener" href="http://www.cocoachina.com/industry/20130821/6842.html">http://www.cocoachina.com/industry/20130821/6842.html</a></p>
<h2 id="iOS中NSString转换成HEX（十六进制）-NSData转换成int"><a href="#iOS中NSString转换成HEX（十六进制）-NSData转换成int" class="headerlink" title="iOS中NSString转换成HEX（十六进制）-NSData转换成int"></a>iOS中NSString转换成HEX（十六进制）-NSData转换成int</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;0xff055008&quot;;</span><br><span class="line">//先以16为参数告诉strtoul字符串参数表示16进制数字，然后使用0x%X转为数字类型</span><br><span class="line">unsigned long red = strtoul([str UTF8String],0,16);</span><br><span class="line">//strtoul如果传入的字符开头是“0x”,那么第三个参数是0，也是会转为十六进制的,这样写也可以：</span><br><span class="line">unsigned long red = strtoul([@&quot;0x6587&quot; UTF8String],0,0);</span><br><span class="line">NSLog(@&quot;转换完的数字为：%lx&quot;,red);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 十六进制转换为普通字符串的。 </span><br><span class="line">+ (NSString *)stringFromHexString:(NSString *)hexString &#123; // </span><br><span class="line"> </span><br><span class="line">char *myBuffer = (char *)malloc((int)[hexString length] / 2 + 1); </span><br><span class="line">bzero(myBuffer, [hexString length] / 2 + 1); </span><br><span class="line">for (int i = 0; i &lt; [hexString length] - 1; i += 2) &#123; </span><br><span class="line">unsigned int anInt; </span><br><span class="line">NSString * hexCharStr = [hexString substringWithRange:NSMakeRange(i, 2)]; </span><br><span class="line">NSScanner * scanner = [[[NSScanner alloc] initWithString:hexCharStr] autorelease]; </span><br><span class="line">[scanner scanHexInt:&amp;anInt]; </span><br><span class="line">myBuffer[i / 2] = (char)anInt; </span><br><span class="line">&#125; </span><br><span class="line">NSString *unicodeString = [NSString stringWithCString:myBuffer encoding:4]; </span><br><span class="line">NSLog(@&quot;------字符串=======%@&quot;,unicodeString); </span><br><span class="line">return unicodeString; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">//普通字符串转换为十六进制的。 </span><br><span class="line"> </span><br><span class="line">+ (NSString *)hexStringFromString:(NSString *)string&#123; </span><br><span class="line">NSData *myD = [string dataUsingEncoding:NSUTF8StringEncoding]; </span><br><span class="line">Byte *bytes = (Byte *)[myD bytes]; </span><br><span class="line">//下面是Byte 转换为16进制。 </span><br><span class="line">NSString *hexStr=@&quot;&quot;; </span><br><span class="line">for(int i=0;i&lt;[myD length];i++) </span><br><span class="line"> </span><br><span class="line">&#123; </span><br><span class="line">NSString *newHexStr = [NSString stringWithFormat:@&quot;%x&quot;,bytes[i]&amp;0xff];///16进制数 </span><br><span class="line"> </span><br><span class="line">if([newHexStr length]==1) </span><br><span class="line"> </span><br><span class="line">hexStr = [NSString stringWithFormat:@&quot;%@0%@&quot;,hexStr,newHexStr]; </span><br><span class="line"> </span><br><span class="line">else </span><br><span class="line"> </span><br><span class="line">hexStr = [NSString stringWithFormat:@&quot;%@%@&quot;,hexStr,newHexStr]; </span><br><span class="line">&#125; </span><br><span class="line">return hexStr; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//int 转data</span><br><span class="line">int i = 1; </span><br><span class="line">NSData *data = [NSData dataWithBytes: &amp;i length: sizeof(i)]; </span><br><span class="line">//data 转int</span><br><span class="line">int i; </span><br><span class="line">[data getBytes: &amp;i length: sizeof(i)]; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>转自<a target="_blank" rel="noopener" href="https://blog.csdn.net/fucheng56/article/details/19962547">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/16/%E5%85%B6%E4%BB%96%E6%9D%82%E9%A1%B9/" data-id="clvq0zjc9000k7qqt4dxe667z" data-title="其他杂项" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="chrome-插件" class="h-entry article article-type-chrome" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/12/%E6%8F%92%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2018-04-12T06:49:18.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/12/%E6%8F%92%E4%BB%B6/">chrome插件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>目标：去掉HTML上侧标栏的广告</p>
<p>做个Chrome的小插件</p>
<p>本来想做Safari的插件的，但是资料太少，似乎还需要证书……., 还是做个Chrome的算了吧。</p>
<h2 id="必要的文件"><a href="#必要的文件" class="headerlink" title="必要的文件"></a>必要的文件</h2><p>Chrome插件必要的是一个manifest.json</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 清单文件的版本，这个必须写，而且必须是2</span><br><span class="line">    &quot;manifest_version&quot;: 2,</span><br><span class="line">    // 插件的名称</span><br><span class="line">    &quot;name&quot;: &quot;去侧边广告的&quot;,</span><br><span class="line">    // 插件的版本</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    // 插件描述</span><br><span class="line">    &quot;description&quot;: &quot;简单的Chrome扩展demo&quot;,    </span><br><span class="line">    &quot;content_scripts&quot;: [ &#123;</span><br><span class="line">        &quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;],</span><br><span class="line">        &quot;js&quot;: [&quot;jq.js&quot;,&quot;test.js&quot;],</span><br><span class="line">        &quot;run_at&quot;: &quot;document_start&quot;</span><br><span class="line">    &#125; ],</span><br><span class="line">    // 权限申请</span><br><span class="line">    &quot;permissions&quot;: [</span><br><span class="line">        &quot;contextMenus&quot;, // 右键菜单</span><br><span class="line">        &quot;tabs&quot;, // 标签</span><br><span class="line">        &quot;notifications&quot;, // 通知</span><br><span class="line">        &quot;webRequest&quot;, // web请求</span><br><span class="line">        &quot;webRequestBlocking&quot;,</span><br><span class="line">        &quot;storage&quot;, // 插件本地存储</span><br><span class="line">        &quot;http://*/*&quot;, // 可以通过executeScript或者insertCSS访问的网站</span><br><span class="line">        &quot;https://*/*&quot; // 可以通过executeScript或者insertCSS访问的网站</span><br><span class="line">    ],</span><br><span class="line">    // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span><br><span class="line">    &quot;omnibox&quot;: &#123; &quot;keyword&quot; : &quot;go&quot; &#125;,</span><br><span class="line">    // devtools页面入口，注意只能指向一个HTML文件，不能是JS文件</span><br><span class="line">    &quot;devtools_page&quot;: &quot;devtools.html&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的content_scripts是关键，我们就是通过这个test.js把HTML中的，aside隐藏</p>
<p>test.js代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;DOMContentLoaded&#x27;, function()</span><br><span class="line">&#123;</span><br><span class="line">    // 为了防止有js控制iframe的显示之类的问题，这里一直循环，有性能考虑的话就去掉</span><br><span class="line">    window.setInterval(function () &#123;</span><br><span class="line">        $(&quot;aside&quot;).remove();</span><br><span class="line">        $(&quot;iframe&quot;).remove();</span><br><span class="line">    &#125;,1000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此处用了jQuery，所以还需要引用文件</p>
<h2 id="在Chrome中打开开发模式，引入本地已经解压的扩展程序"><a href="#在Chrome中打开开发模式，引入本地已经解压的扩展程序" class="headerlink" title="在Chrome中打开开发模式，引入本地已经解压的扩展程序"></a>在Chrome中打开开发模式，引入本地已经解压的扩展程序</h2><p>然后就可以了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/12/%E6%8F%92%E4%BB%B6/" data-id="clvq0zjca000o7qqt0k3odq5o" data-title="chrome插件" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-GCD之同步任务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/28/GCD%E4%B9%8B%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2018-03-28T09:31:01.000Z" itemprop="datePublished">2018-03-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/28/GCD%E4%B9%8B%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1/">GCD之同步任务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>平时没有怎么用的概念，但是很重要，这里记一下</p>
<h1 id="怎么让线程同步"><a href="#怎么让线程同步" class="headerlink" title="怎么让线程同步"></a>怎么让线程同步</h1><h2 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h2><p>需要在大量任务都执行完成后，执行其他任务，可以用 Dispatch Group</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 可以理解为一个任务组，组内的任务完成后就会调用dispatch_group_notify</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    if (i == 999) &#123;</span><br><span class="line">        NSLog(@&quot;11111111&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;22222222&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;33333333&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;done&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2018年4月18日更新"><a href="#2018年4月18日更新" class="headerlink" title="2018年4月18日更新"></a>2018年4月18日更新</h3><p>对于网络请求这种异步任务，还需要使用 dispatch_group_enter和dispatch_group_leave,来手动处理下，先上代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务1开始&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;任务1结束&quot;);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务2开始&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;任务2结束&quot;);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;完成了&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>输出为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">17:31:39.314251+0800 testP[29849:2247791] 任务2开始</span><br><span class="line">17:31:39.314251+0800 testP[29849:2247785] 任务1开始</span><br><span class="line">17:31:40.317949+0800 testP[29849:2247791] 任务2结束</span><br><span class="line">17:31:41.318231+0800 testP[29849:2247785] 任务1结束</span><br><span class="line">17:31:41.318588+0800 testP[29849:2247785] 完成了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到任务1和任务2同时执行，因为任务1耗时2秒，所以在任务2后1秒完成，然后发出通知，</p>
<p>dispatch_group_enter和dispatch_group_leave总是成对出现，不然可能导致group没有被释放，从而没有notify；或者group提前释放，导致EXC_BAD_INSTRUCTION,group提前释放</p>
<p>dispatch_group_enter和dispatch_group_leave可以理解为给group添加手动计数，dispatch_group_enter会给group加1，dispatch_group_leave就是减一，group初始计数为0。</p>
<p>当group初始计数为0时，就会执行notify通知，比如如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;完成了&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务1开始&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;任务1结束&quot;);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务2开始&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;任务2结束&quot;);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17:45:46.296758+0800 testP[30209:2259157] 任务2开始</span><br><span class="line">17:45:46.296758+0800 testP[30209:2259158] 任务1开始</span><br><span class="line">17:45:46.296766+0800 testP[30209:2259150] 完成了</span><br><span class="line">17:45:47.301499+0800 testP[30209:2259157] 任务2结束</span><br><span class="line">17:45:48.299812+0800 testP[30209:2259158] 任务1结束</span><br></pre></td></tr></table></figure>

<p>将dispatch_group_notify移到最前，就不会在group完成后得到notify，而是提前执行了</p>
<h2 id="dispatch-barrier-sync-和-dispatch-barrier-async"><a href="#dispatch-barrier-sync-和-dispatch-barrier-async" class="headerlink" title="dispatch_barrier_sync 和 dispatch_barrier_async"></a>dispatch_barrier_sync 和 dispatch_barrier_async</h2><p><img src="https://coding.net/u/chdo/p/CDResource/git/raw/master/20150726170216381.png" alt="网上找到的"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// dispatch_barrier_sync 这个和  dispatch_async与dispatch_sync之间的区别类似</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;000000&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;4&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;5&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;6&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、dispatch_semaphore_create 创建一个semaphore  就是创建一个全局的变量，小于0时会阻塞当前线程</span><br><span class="line">2、dispatch_semaphore_signal 发送一个信号       给信号量加1</span><br><span class="line">3、dispatch_semaphore_wait 等待信号   给信号量减1</span><br></pre></td></tr></table></figure>
<p>这个东西本质是就是立flag，让flag小于0，线程就阻塞了，只有让flag大于0，才能继续</p>
<p>网上的说明例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 创建队列组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">// 创建信号量，并且设置值为10</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">for (int i = 0; i &lt; 100; i++)&#123;</span><br><span class="line">/*</span><br><span class="line"> *  由于是异步执行的，所以每次循环Block里面的dispatch_semaphore_signal根本还没有执行就会执行dispatch_semaphore_wait，</span><br><span class="line"> *  从而semaphore-1.当循环10此后，semaphore等于0，则会阻塞线程，直到执行了Block的dispatch_semaphore_signal 才会继续执行</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;%i&quot;,i);</span><br><span class="line">        sleep(2);</span><br><span class="line">        // 每次发送信号则semaphore会+1，</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用1 网络请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_block BOOL isok = NO;</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_t sema = dispatch_semaphore_create(0);</span><br><span class="line">Engine *engine = [[Engine alloc] init];</span><br><span class="line">[engine queryCompletion:^(BOOL isOpen) &#123;</span><br><span class="line">    isok = isOpen;</span><br><span class="line">    dispatch_semaphore_signal(sema);</span><br><span class="line">&#125; onError:^(int errorCode, NSString *errorMessage) &#123;</span><br><span class="line">    isok = NO;</span><br><span class="line">    dispatch_semaphore_signal(sema);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">// todo what you want to do after net callback</span><br></pre></td></tr></table></figure>

<p>应用2  获取权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//创建通讯簿的引用</span><br><span class="line">addBook=ABAddressBookCreateWithOptions(NULL, NULL);</span><br><span class="line">//创建一个出事信号量为0的信号</span><br><span class="line">dispatch_semaphore_t sema=dispatch_semaphore_create(0);</span><br><span class="line">//申请访问权限</span><br><span class="line">ABAddressBookRequestAccessWithCompletion(addBook, ^(bool greanted, CFErrorRef error)</span><br><span class="line">&#123;</span><br><span class="line">    //greanted为YES是表示用户允许，否则为不允许</span><br><span class="line">    if (!greanted) &#123;</span><br><span class="line">        tip=1;</span><br><span class="line">    &#125;</span><br><span class="line">    //发送一次信号</span><br><span class="line">    dispatch_semaphore_signal(sema);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">//等待信号触发</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/28/GCD%E4%B9%8B%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1/" data-id="clvq0zjbw00047qqthibd6s5c" data-title="GCD之同步任务" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CDChatList" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/26/CDChatList/" class="article-date">
  <time class="dt-published" datetime="2018-03-26T14:02:50.000Z" itemprop="datePublished">2018-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/26/CDChatList/">CDChatList</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/chdo002/CDChatList">https://github.com/chdo002/CDChatList</a></p>
<h1 id="CDChatList"><a href="#CDChatList" class="headerlink" title="CDChatList"></a>CDChatList</h1><p><a target="_blank" rel="noopener" href="https://travis-ci.org/chdo002/CDChatList"><img src="http://img.shields.io/travis/chdo002/CDChatList.svg?style=flat" alt="CI Status"></a><br><a target="_blank" rel="noopener" href="http://cocoapods.org/pods/CDChatList"><img src="https://img.shields.io/cocoapods/v/CDChatList.svg?style=flat" alt="Version"></a><br><a target="_blank" rel="noopener" href="http://cocoapods.org/pods/CDChatList"><img src="https://img.shields.io/cocoapods/l/CDChatList.svg?style=flat" alt="License"></a><br><a target="_blank" rel="noopener" href="http://cocoapods.org/pods/CDChatList"><img src="https://img.shields.io/cocoapods/p/CDChatList.svg?style=flat" alt="Platform"></a></p>
 <img src="https://coding.net/u/chdo/p/CDResource/git/raw/master/gif1.GIF" width = "224" height = "400" alt="图片名称" align=center display=inlie-block />
 <img src="https://coding.net/u/chdo/p/CDResource/git/raw/master/gif2.GIF" width = "224" height = "400" alt="图片名称" align=center display=inlie-block/>


<p>高性能的聊天页面解决方案<br>对聊天列表的高度封装，可灵活配置页面样式</p>
<p>聊天界面其实大同小异，所以这里封装了一个聊天的组件，使用CoreText和手动代码布局，尽量实现简单，通用，高效，易于维护。</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>CDChatListView: UITableView 视图，聊天页面主体</p>
<p>CDBaseMsgCell: 实现消息气泡基本视图</p>
<p>CDTextTableViewCell、CDImageTableViewCell、CDAudioTableViewCell: 继承自CDBaseMsgCell，实现响应功能。<br>CDSystemTableViewCell: 特殊消息气泡，实现系统通知</p>
<p>CellCaculator： tableview布局计算，并提前渲染cell</p>
<p>ChatConfiguration： chatlist配置类组，UI定制，及资源等</p>
<h4 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h4><p>CDLabel： 富文本标签<br>CDChatInputBox： 输入框封装组件</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>支持至iOS 11</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;CDChatList&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="配置-CDChatList"><a href="#配置-CDChatList" class="headerlink" title="配置 CDChatList"></a>配置 CDChatList</h3><p>ChatHelpr负责ChatHelpr的UI配置，及组件的资源文件设置</p>
<p>UI配置及资源文件都有默认，所以无需自定义的话，就可以跳过组件的配置</p>
<h3 id="添加-CDChatList-视图"><a href="#添加-CDChatList-视图" class="headerlink" title="添加 CDChatList 视图"></a>添加 CDChatList 视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CDChatListView *list = [[CDChatListView alloc] initWithFrame:self.view.bounds];</span><br><span class="line">list.msgDelegate = self;</span><br><span class="line">self.listView = list;</span><br><span class="line">[self.view addSubview:self.listView];</span><br></pre></td></tr></table></figure>

<p>CDChatList会将视图控制器automaticallyAdjustsScrollViewInsets及contentInsetAdjustmentBehavior设为NO及Never，并适应导航栏高度</p>
<h3 id="消息模型-MessageModalProtocal"><a href="#消息模型-MessageModalProtocal" class="headerlink" title="消息模型  MessageModalProtocal"></a>消息模型  MessageModalProtocal</h3><p>可以使用自己的消息模型，消息模型需遵守MessageModalProtocal，实现相关属性</p>
<h3 id="组件事件-ChatListProtocol"><a href="#组件事件-ChatListProtocol" class="headerlink" title="组件事件 ChatListProtocol"></a>组件事件 ChatListProtocol</h3><h4 id="从组件发出的消息"><a href="#从组件发出的消息" class="headerlink" title="从组件发出的消息"></a>从组件发出的消息</h4><p>消息列表请求加载更多消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(void)chatlistLoadMoreMsg: (CDChatMessage)topMessage</span><br><span class="line">callback: (void(^)(CDChatMessageArray))finnished;</span><br></pre></td></tr></table></figure>

<p>消息中的点击事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)chatlistClickMsgEvent: (ChatListInfo *)listInfo;</span><br></pre></td></tr></table></figure>
<h4 id="向组件发消息"><a href="#向组件发消息" class="headerlink" title="向组件发消息"></a>向组件发消息</h4><p>添加新的数据到底部</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)addMessagesToBottom: (CDChatMessageArray)newBottomMsgArr;</span><br></pre></td></tr></table></figure>

<p>更新数据源中的某条消息模型(主要是为了更新UI上的消息状态)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)updateMessage:(CDChatMessage)message;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="收-发消息"><a href="#收-发消息" class="headerlink" title="收&#x2F;发消息"></a>收&#x2F;发消息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 发</span><br><span class="line">&#123;</span><br><span class="line">	MessageModal *modal;</span><br><span class="line">&#125;</span><br><span class="line">-(void)send&#123;</span><br><span class="line">	modal = [[MessageModal alloc] init];</span><br><span class="line">	modal.msgState = CDMessageStateSending;</span><br><span class="line">	modal.createTime = ...;</span><br><span class="line">	modal.msg = ...;</span><br><span class="line">	modal.msgType = ...;</span><br><span class="line">	[chatList addMessagesToBottom: modal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)sendCallBack:(BOOL)isSuccess&#123;</span><br><span class="line">	modal.msgState = isSuccess;  // 此处应处理成枚举</span><br><span class="line">	[chatList updateMessage: modal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 收</span><br><span class="line">-(void)receivedNewMessage:(MessageModal *)modal&#123;</span><br><span class="line">	[chatList addMessagesToBottom: modal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="下拉加载更多消息"><a href="#下拉加载更多消息" class="headerlink" title="下拉加载更多消息"></a>下拉加载更多消息</h4><p>消息列表被下拉时，触发此回调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)chatlistLoadMoreMsg: (CDChatMessage)topMessage</span><br><span class="line">callback: (void(^)(CDChatMessageArray))finnished</span><br><span class="line">&#123;</span><br><span class="line">	// 根据topMessage 获取更多消息</span><br><span class="line">	NSArray *msgArr = [self getMoreMessageFrom: topMessage amount: 10];</span><br><span class="line">	callback(msgArr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="消息点击事件"><a href="#消息点击事件" class="headerlink" title="消息点击事件"></a>消息点击事件</h4><p>目前消息体重处理了 文本点击 及 图片点击 事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(void)chatlistClickMsgEvent: (ChatListInfo *)listInfo&#123;</span><br><span class="line">	if (listInfo.eventType == ChatClickEventTypeTEXT)&#123;</span><br><span class="line">		// 点击的文本</span><br><span class="line">		listInfo.clickedText</span><br><span class="line">		// 点击的文字位置  防止有相同的可点击文字</span><br><span class="line">		listInfo.range</span><br><span class="line">		// 被点击文本的隐藏信息   e.g.  &lt;a title=&quot;转人工&quot; href=&quot;doTransfer&quot;&gt;</span><br><span class="line">		listInfo.clickedTextContent</span><br><span class="line">	&#125; else if (listInfo.eventType == ChatClickEventTypeIMAGE)&#123;</span><br><span class="line">		// 图片</span><br><span class="line">		listInfo.image</span><br><span class="line">		// 图片在tableview中的位置</span><br><span class="line">		listInfo.msgImageRectInTableView</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>自定义消息内容匹配</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/26/CDChatList/" data-id="clvq0zjbd00007qqtet6c7w6b" data-title="CDChatList" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-利用Runtime替换方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/03/24/%E5%88%A9%E7%94%A8Runtime%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-03-24T04:11:33.000Z" itemprop="datePublished">2018-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/03/24/%E5%88%A9%E7%94%A8Runtime%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95/">利用Runtime替换方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>小组最近想要去掉taikingdata，自己做个用户行为跟踪的组件，要点是，不能影响应用的性能，做到无感知记录，不需要修改原来工程的代码，任务排到我这，小小调研下，决定利用runtime相关方法，现记录如下</p>
<h2 id="记录button点击事件"><a href="#记录button点击事件" class="headerlink" title="记录button点击事件"></a>记录button点击事件</h2><blockquote>
<p> Method Swizzling </p>
</blockquote>
<h6 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void swizzling(Class orignClass, SEL orignSelector, Class switchClass, SEL switchSelector)&#123;</span><br><span class="line">    // 原来的方法</span><br><span class="line">    Method orginMethod = class_getInstanceMethod(orignClass, orignSelector);</span><br><span class="line">    // 原来的实现</span><br><span class="line">    IMP originImp = method_getImplementation(orginMethod);</span><br><span class="line">    // 新的方法</span><br><span class="line">    Method switchMethod = class_getInstanceMethod(switchClass, switchSelector);</span><br><span class="line">    // 给原来的方法换成新的实现</span><br><span class="line">    method_exchangeImplementations(orginMethod, switchMethod);</span><br><span class="line">    // 将旧的实现新的方法添加到类中</span><br><span class="line">    class_addMethod(orignClass, switchSelector, originImp, method_getTypeEncoding(orginMethod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此方法的目的，将目标类的某个需要监听的方法的实现，换成自己的实现，在自己的实现中，又会调回原来的方法的实现，这样包装一下就可以监听到了。<br>需要注意的一个细节是，原方法的参数列表是未知的，需要特殊处理，这边是监听button的点击事件，所以，就简单的判断了一下，可以覆盖到全部的情况。</p>
<h6 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// APP启动时，加载所有的类，会调用load 方法</span><br><span class="line">+(void)load&#123;</span><br><span class="line">	/*</span><br><span class="line">	先替换掉，button的addtarget方法，这样可以拿到点击的响应方法，然后替换他</span><br><span class="line">	*/</span><br><span class="line">    // 原来的方法</span><br><span class="line">    SEL originSel = @selector(addTarget:action:forControlEvents:);</span><br><span class="line">    // 自己的方法</span><br><span class="line">    SEL switchSel = @selector(newAddTarget:action:forContrState:);</span><br><span class="line">    swizzling(UIButton.class, originSel, TRACK.class, switchSel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(void)newAddTarget:(id)targ action:(SEL)ac forContrState:(UIControlEvents)eve&#123;</span><br><span class="line">	// 此时的self已经指向了UIButton,所以要调用newAddTarget 让他执行旧的实现</span><br><span class="line">    [self newAddTarget:targ action:ac forContrState:eve];</span><br><span class="line"></span><br><span class="line">    // 获得响应方法的参数，正确的实现方式是动态的实现hook方法，并制定参数，但是这里就简单实现了</span><br><span class="line">    unsigned int paraCount = method_getNumberOfArguments(class_getInstanceMethod([targ class], ac));</span><br><span class="line">    </span><br><span class="line">    if (paraCount == 2) &#123;  // 至少有两个参数 self:调方法的对象  _cmd:SEL 方法签名</span><br><span class="line">        swizzling([targ class], ac, TRACK.class, @selector(tapAcion));</span><br><span class="line">    &#125; else &#123; // 有多余的参数的话，则应该是多了个UIbutton</span><br><span class="line">        swizzling([targ class], ac, TRACK.class, @selector(tapActionWithPara:));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对应的替换方法</span><br><span class="line">-(void)tapAcion&#123;</span><br><span class="line">    [self performSelector:@selector(tapAcion)];</span><br><span class="line">    NSLog(@&quot;监听到了&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)tapActionWithPara:(UIButton *)but&#123;</span><br><span class="line">    [self performSelector:@selector(tapActionWithPara:) withObject:but];</span><br><span class="line">    NSLog(@&quot;监听到了2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/03/24/%E5%88%A9%E7%94%A8Runtime%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%B3%95/" data-id="clvq0zjca000l7qqtd03t36hr" data-title="利用Runtime替换方法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/runtime-track-%E5%9F%8B%E7%82%B9/" rel="tag">runtime track 埋点</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-webpack" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/10/21/webpack/" class="article-date">
  <time class="dt-published" datetime="2017-10-20T16:18:59.000Z" itemprop="datePublished">2017-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/10/21/webpack/">webpack</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><label style="background:#DCDCDC; display: flex; align-items:center;justify-content:center; height: 50px;margin:0px;padding:0px;">–从这里开始看的</label><br><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/42e11515c10f">入门Webpack，看这篇就够了</a></p>
<!-- <label style="background:#DCDCDC; display: flex; align-items:center;justify-content:center; height: 50px;margin:0px;padding:0px;">--从这里开始看的</label> -->

<video id="video" src="http://101.44.1.11/flvfiles/3074000006DCDE15/vf2.mtime.cn/Video/2017/10/23/flv/171023142356212088.flv" poster="http://img5.mtime.cn/mg/2017/10/23/145018.62596225.jpg" controls="controls">
</video>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/10/21/webpack/" data-id="clvq0zjc7000h7qqtcauhd0c5" data-title="webpack" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-reactnative" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/10/09/reactnative/" class="article-date">
  <time class="dt-published" datetime="2017-10-09T14:52:31.000Z" itemprop="datePublished">2017-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/10/09/reactnative/">reactnative</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>  <a target="_blank" rel="noopener" href="http://reactnative.cn/">reactnative 中文教程</a></p>
<p>  <a target="_blank" rel="noopener" href="http://facebook.github.io/react-native/">reactnative GitHub</a></p>
<p>  <a target="_blank" rel="noopener" href="http://facebook.github.io/react-native/docs/integration-with-existing-apps.html">集成React Native 到APP中</a><br>  — podfile中要加入， <code>BatchedBridge</code></p>
<p>  <a target="_blank" rel="noopener" href="http://www.runoob.com/react/react-tutorial.html">React 菜鸟教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/10/09/reactnative/" data-id="clvq0zjc7000f7qqt128ee720" data-title="reactnative" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rn/" rel="tag">rn</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/http-www-runoob-com-sqlite/" rel="tag">http:&#x2F;&#x2F;www.runoob.com&#x2F;sqlite&#x2F;</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rn/" rel="tag">rn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime-track-%E5%9F%8B%E7%82%B9/" rel="tag">runtime track 埋点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shadowsocks/" rel="tag">shadowsocks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weex/" rel="tag">weex</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/http-www-runoob-com-sqlite/" style="font-size: 10px;">http://www.runoob.com/sqlite/</a> <a href="/tags/rn/" style="font-size: 10px;">rn</a> <a href="/tags/runtime-track-%E5%9F%8B%E7%82%B9/" style="font-size: 10px;">runtime track 埋点</a> <a href="/tags/shadowsocks/" style="font-size: 10px;">shadowsocks</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/weex/" style="font-size: 10px;">weex</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/15/NSArrary%E5%BC%BA%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/">NSArrary强引用问题</a>
          </li>
        
          <li>
            <a href="/2018/08/27/iOS%E5%90%AF%E5%8A%A8%E8%A7%A3%E6%9E%90/">iOS启动解析</a>
          </li>
        
          <li>
            <a href="/2018/08/07/NSNull%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8D/">NSNull导致的性能下降</a>
          </li>
        
          <li>
            <a href="/2018/06/17/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">LeetCode</a>
          </li>
        
          <li>
            <a href="/2018/05/23/SQLite%20-%20C:C++/">SQLite - C/C++</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 chdo002<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>