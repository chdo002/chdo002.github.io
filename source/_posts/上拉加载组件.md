---
title: 上拉加载组件
date: 2024-05-03 11:28:28
tags: flutter
---

flutter中有个很好用的Sliver `CupertinoSliverRefreshControl`，但是没有提供对应的上拉组件，三方库中有不少不错的支持的刷新组件，比如[flutter_easy_refresh](https://github.com/xuelongqy/flutter_easy_refresh)。但是基本是需要再滚动视图外包上一个另外的监听组件,似乎没有以Sliver方式实现的简单的上拉组件，所以我按照`CupertinoSliverRefreshControl`的实现原理，简单实现一个上拉sliver组件。

## `CupertinoSliverRefreshControl`实现原理

### 先回顾下Sliver的布局逻辑:
1、Viewport 将当前布局和配置信息通过 SliverConstraints 传递给 Sliver。
2、Sliver 确定自身的位置、绘制等信息，保存在 geometry 中（一个 SliverGeometry 类型的对象）。
3、Viewport 读取 geometry 中的信息来对 Sliver 进行布局和绘制。

而该段逻辑主要在RenderSliver的`performLayout`方法中，需要用到`SliverConstraints`的如下几个属性
```
class SliverConstraints extends Constraints {
    //当前Sliver理论上（可能会固定在顶部）已经滑出可视区域的总偏移
    double? scrollOffset;
    //上一个 sliver 覆盖当前 sliver 的长度（重叠部分的长度），通常在 sliver 是 pinned/floating
    //或者处于列表头时,距离顶部的距离
    double? overlap;
    ...
}
```

当用户滑动列表，传递给Sliver的约束会不断变化，设置新的geometry和重新布局子组件
```
const SliverGeometry({
  this.scrollExtent = 0.0, // sliver占用主轴的高度，决定Sliver在Viewport可滚动的距离，为0时不影响子组件布局显示，但是不占用滚动高度，比如排列在首尾的Sliver在用户结束滑动时，会回弹出Viewport
  this.paintExtent = 0.0, // 可视区域中的绘制长度，会被传递到Boxcontrains中的minHeight
  this.paintOrigin = 0.0, // 绘制的坐标原点，相对于自身布局位置，小于0时也能生效
  //在 Viewport中占用的长度；如果列表滚动方向是垂直方向，则表示列表高度。主要影响下一个Sliver的位置
  //范围[0,paintExtent]
  double? layoutExtent, 
  this.maxPaintExtent = 0.0,//最大绘制长度
  //scrollExtent的修正值：layoutExtent变化后，为了防止sliver突然跳动（应用新的layoutExtent）
  //可以先进行修正，具体的作用在后面 SliverFlexibleHeader 示例中会介绍。
  this.scrollOffsetCorrection,
  ...
}) 
```

### `CupertinoSliverRefreshControl`结构
先看下`CupertinoSliverRefreshControl`的两个主要组成元素。
- `CupertinoSliverRefreshControl`
    一个StatefulWidget，他管理的状态就是`RefreshIndicatorMode`，并通过transitionNextState方法来更新`RefreshIndicatorMode`。
- `_CupertinoSliverRefresh`是个SingleChildRenderObjectWidget，他接受CupertinoSliverRefreshControl的参数配置，并传递给`_RenderCupertinoSliverRefresh`。`_RenderCupertinoSliverRefresh`是个Sliver，他本身不管理刷新状态，只负责根据目前的sliver约束条件和CupertinoSliverRefreshControl的参数配置来布局和绘制。

通过下面的伪代码，表达下大概是这样的组成方式
```
CupertinoSliverRefreshControl (refreshIndicatorExtent){
    // CupertinoSliverRefreshControl的state
    _CupertinoSliverRefreshControlState { // 负责管理刷新状态
        bool _hasLayoutExtent;
        Widget build(context) {
            return _CupertinoSliverRefresh( // 负责绘制刷新组件
                refreshIndicatorExtent:widget.refreshIndicatorExtent, // 刷新组件的指定高度
                hasLayoutExtent:_hasLayoutExtent, // 是否要让子组件常驻显示，默认情况下比如下拉距离不够，子组件还是会回弹的，只有下拉足够距离_hasLayoutExtent才未true
                child:LayoutBuilder(builder:(context,constrain){ // 这里加个LayoutBuilder的目的是为了拿到constrain，
                    latestIndicatorBoxExtent = constraints.maxHeight; // 保存布局高度，据此来判断当前刷新状态
                    refreshState = transitionNextState(); // transitionNextState的大概逻辑是根据latestIndicatorBoxExtent的高度，和之前保存的状态，得出目前的最新状态（更新_hasLayoutExtent），必要时会触发setstate刷新
                    return widget.build(context, refreshState...);
                })
            );
        }
    }
}

_CupertinoSliverRefresh {
    // _CupertinoSliverRefresh的RenderSliver
    _RenderCupertinoSliverRefresh {
        double _refreshIndicatorExtent; // 
        bool _hasLayoutExtent; //
        performLayout() {
            // 计算子组件的刷新高度
            final double layoutExtent = (_hasLayoutExtent ? 1.0 : 0.0) * _refreshIndicatorExtent;
            // 判断此时是否需要显示子组件
            final bool active = constraints.overlap < 0.0 || layoutExtent > 0.0;
            
            // 计算子组件的高度
            final double overscrolledExtent = constraints.overlap < 0.0 ? constraints.overlap.abs() : 0.0;
            // 布局子组件
            child!.layout(
              constraints.asBoxConstraints(
                maxExtent: layoutExtent + overscrolledExtent,
              ),
              parentUsesSize: true,
            );
            
            if (active) {
              // 显示子组件的情况，计算当前sliver的布局
              geometry = SliverGeometry(
                scrollExtent: layoutExtent,
                paintOrigin: -overscrolledExtent - constraints.scrollOffset,
                paintExtent: max(
                  max(child!.size.height, layoutExtent) - constraints.scrollOffset,
                  0.0,
                ),
                maxPaintExtent: max(
                  max(child!.size.height, layoutExtent) - constraints.scrollOffset,
                  0.0,
                ),
                layoutExtent: max(layoutExtent - constraints.scrollOffset, 0.0),
              );
            } else {
              // 不显示子组件的情况，直接隐藏，此时不会触发LayoutBuilder的绘制
              geometry = SliverGeometry.zero;
            }
        }
    }
}

```
### `CupertinoSliverRefreshControl`总结
发现`CupertinoSliverRefreshControl`的逻辑并不复杂，主要通过Sliver的布局变化，触发刷新还是隐藏sliver，其中主要注意点点是：
- `_CupertinoSliverRefreshControlState`中使用了`LayoutBuilder`，其目的是为了拿到sliver返回的Box布局信息，来判断当前的滚动状态，因为`_CupertinoSliverRefresh`中并没有给到一个回调机制
- 在`_CupertinoSliverRefresh`中动态修改scrollExtent，其实会引起Viewport的抖动，因为后续的sliver布局都受到自己的高度影响，所以geometry中提供了`scrollOffsetCorrection`这个修正属性。


## 实现一个`CupertinoSliverLoadMoreControl`

### `CupertinoSliverLoadMoreControl`结构
我们的组件和`CupertinoSliverRefreshControl`的结构保持一致，尽量不更改使用期望，只是增加了自动加载和预加载的功能，因为在Viewport中的